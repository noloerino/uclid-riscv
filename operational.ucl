
// Very similar to cpu model in example 3.2 of tutorial
// https://github.com/uclid-org/uclid/blob/master/tutorial/tutorial.pdf
module cpu {
    type * = common.*;
    define * = common.*;
    const * = instructions.*;
    define * = instructions.*;

    input imem  : mem_t;
    var dmem    : mem_t;
    var regfile : regfile_t;
    var pc      : pc_t;
    var inst    : inst_t;

    procedure compute_i_arith(f3 : bv3, rs1_val : reg_data_t, imm : bv12)
        returns (rd_val : reg_data_t)
    {
        var imm_ext : reg_data_t;
        var shamt : bv32;
        imm_ext  = bv_sign_extend(20, imm);
        shamt = bv_zero_extend(27, imm[4:0]);
        case
            (f3 == F3_ADDI) : { rd_val = rs1_val + imm_ext; }
            // FIX: bv_left_shift seems not to type check until it reaches the smt backend
            (f3 == F3_SLLI) : { rd_val = bv_left_shift(shamt, rs1_val); }
            (f3 == F3_SLTI) : { if (imm_ext > rs1_val) { rd_val = 1bv32; } else { rd_val = 0bv32; } }
            // TODO check how to do unsigned vs signed comparisons
            (f3 == F3_SLTIU) : { if (imm_ext > rs1_val) { rd_val = 1bv32; } else { rd_val = 0bv32; } }
            (f3 == F3_XORI) : { rd_val = rs1_val ^ imm_ext; }
            (f3 == F3_SRI) : {
                if (imm[10:10] == 0bv1) {
                    // TODO double check behavior for upper immediate bits
                    rd_val = bv_a_right_shift(shamt, rs1_val);
                } else {
                    rd_val = bv_l_right_shift(shamt, rs1_val);
                }
            }
            (f3 == F3_ORI) : { rd_val = rs1_val | imm_ext; }
            (f3 == F3_ANDI) : { rd_val = rs1_val & imm_ext; }
            // TODO handle invalid instructions (restrict w/ assumption?)
            default : { rd_val = 0bv32; }
        esac
    }

    procedure compute_i_mem(f3: bv3, rs1_val : reg_data_t, imm : bv12)
        returns (rd_val : reg_data_t)
    {
        var addr : reg_data_t;
        var word_addr : mem_word_addr_t;
        var word_ofs : bv2;
        var shifted_data : mem_data_t;
        addr = rs1_val + bv_sign_extend(20, imm);
        word_addr = addr[31:2];
        word_ofs = addr[1:0];
        // Shift word by appropriate offset
        // Assumes little endianness (LSB is at byte 0 of word, MSB at byte 3)
        shifted_data = bv_a_right_shift(bv_left_shift(3bv32, bv_zero_extend(30, word_ofs)), dmem[word_addr]);
        case
            (f3 == F3_LB) : { rd_val = bv_sign_extend(24, shifted_data[7:0]); }
            (f3 == F3_LBU) : { rd_val = bv_zero_extend(24, shifted_data[7:0]); }
            (f3 == F3_LH) : { rd_val = bv_sign_extend(16, shifted_data[15:0]); }
            (f3 == F3_LHU) : { rd_val = bv_zero_extend(16, shifted_data[15:0]); }
            (f3 == F3_LW) : { rd_val = shifted_data; }
            // TODO handle invalid instructions
            default : { rd_val = 0bv32; }
        esac
    }

    procedure compute_s(f3: bv3, rs1_val : reg_data_t, imm : bv12, rs2_val : reg_data_t)
        returns (mem_val : mem_data_t)
    {
        // Returns memory value shifted/masked appropriately
        var addr : reg_data_t;
        var word_addr : mem_word_addr_t;
        var bit_ofs: bv32;
        var old_word : mem_data_t;
        addr = rs1_val + bv_sign_extend(20, imm);
        word_addr = addr[31:2];
        bit_ofs = bv_left_shift(3bv32, bv_zero_extend(30, addr[1:0]));
        old_word = dmem[word_addr];
        case
            (f3 == F3_SB) : {
                old_word = old_word & (~bv_left_shift(bit_ofs, 0xFFbv32));
                mem_val = old_word | bv_left_shift(bit_ofs, rs2_val & 0xFFbv32);
            }
            (f3 == F3_SH) : {
                old_word = old_word & (~bv_left_shift(bit_ofs, 0xFFFFbv32));
                mem_val = old_word | bv_left_shift(bit_ofs, rs2_val & 0xFFFFbv32);
            }
            (f3 == F3_SW) : { mem_val = old_word | bv_left_shift(bit_ofs, rs2_val); }
            default : { mem_val = old_word; }
        esac
    }

    procedure exec_inst()
        modifies pc, regfile, dmem;
    {
        var oc : bv7;
        oc = opcode(inst);
        case
            (oc == OPCODE_I_ARITH) : {
                if (rd(inst) != x0) {
                    call (regfile[rd(inst)]) = compute_i_arith(f3(inst), regfile[rs1(inst)], i_imm(inst));
                }
                pc = pc + 4bv32;
            } 
            (oc == OPCODE_I_MEM) : {
                if (rd(inst) != x0) {
                    call (regfile[rd(inst)]) = compute_i_mem(f3(inst), regfile[rs1(inst)], i_imm(inst));
                }
                pc = pc + 4bv32;
            }
            (oc == OPCODE_R) : {
                pc = pc + 4bv32;
            }
            (oc == OPCODE_S) : {
                var word_addr : mem_word_addr_t;
                word_addr = (regfile[rs1(inst)] + bv_sign_extend(20, s_imm(inst)))[31:2];
                call (dmem[word_addr]) = compute_s(f3(inst), regfile[rs1(inst)], s_imm(inst), regfile[rs2(inst)]);
                pc = pc + 4bv32;
            }
            (oc == OPCODE_B) : {
            }
            (oc == OPCODE_U) : {

                pc = pc + 4bv32;
            }
            (oc == OPCODE_J) : {
            }
        esac
    }

    init {
        assume (forall (r : reg_addr_t) :: regfile[r] == 0bv32);
        assume (forall (a : mem_word_addr_t) :: dmem[a] == 0bv32);
        inst = imem[0bv30];
        pc = 0bv32;
    }

    next {
        inst' = imem[pc_to_mem_addr(pc)];
        call exec_inst();
    }
}

module sanity {
    type * = common.*;

    var imem : mem_t;

    instance cpu_0 : cpu (imem : (imem));

    init {
        imem[0bv30] = 0x00000013bv32; // nop
        imem[1bv30] = 0x06400593bv32; // addi a1, x0, 100
        imem[2bv30] = 0x0C800613bv32; // addi a2, x0, 200
        imem[3bv30] = 0x06466593bv32; // ori  a1, a2, 100
    }

    next {
        next (cpu_0);
    }

    invariant s1 : (cpu_0.pc == 12bv32) ==> (cpu_0.regfile[11bv5] == 100bv32);
    invariant s2 : (cpu_0.pc == 16bv32) ==> (cpu_0.regfile[12bv5] == 200bv32);
    invariant s3 : (cpu_0.pc == 20bv32) ==> (cpu_0.regfile[11bv5] == 236bv32);

    control {
        vobj = bmc(5);
        check;
        print_results;
        vobj.print_cex(cpu_0.pc, cpu_0.inst, cpu_0.regfile);
    }
}

module main {
    type * = common.*;
    define * = instructions.*;
    const * = instructions.*;

    var imem : mem_t;

    instance cpu_1 : cpu (imem : (imem));
    instance cpu_2 : cpu (imem : (imem));

    init {
        // Checks that only implemented instructions are generated
        assume (forall (a : mem_word_addr_t) :: opcode(imem[a]) == OPCODE_I_MEM || opcode(imem[a]) == OPCODE_I_ARITH || opcode(imem[a]) == OPCODE_S);
    }

    next {
        next (cpu_1);
        next (cpu_2);
    }

    invariant eq_regs : (forall (r : reg_addr_t) :: cpu_1.regfile[r] == cpu_2.regfile[r]);
    invariant eq_mem : (forall (a : mem_word_addr_t) :: cpu_1.dmem[a] == cpu_2.dmem[a]);
    invariant eq_pc : (cpu_1.pc == cpu_2.pc);
    invariant eq_inst : (cpu_1.inst == cpu_2.inst);

    control {
        vobj = bmc(3);
        check;
        print_results;
        vobj.print_cex(cpu_1.inst, cpu_2.inst, cpu_1.regfile, cpu_2.regfile);
    }
}

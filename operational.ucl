
// Very similar to cpu model in example 3.2 of tutorial
// https://github.com/uclid-org/uclid/blob/master/tutorial/tutorial.pdf
module cpu {
    type * = common.*;
    define * = common.*;
    type * = instructions.*;
    const * = instructions.*;
    define * = instructions.*;
    const * = encdec.*;
    define * = encdec.*;

    input imem  : mem_t;
    var dmem    : mem_t;
    var regfile : regfile_t;
    var pc      : pc_t;
    var inst    : inst_t;

    // ===== BEGIN STATE HELPER FUNCTIONS =====
    procedure do_reg_write(rd : reg_addr_t, value : reg_data_t)
        modifies regfile;
    {
        if (rd != x0) {
            regfile[rd] = value;
        }
    }

    procedure do_mem_read(addr : reg_data_t, width : mem_data_width_t, sext : boolean)
        returns (new_rd_val : reg_data_t)
    {
        var word_addr : mem_word_addr_t;
        var word_ofs : bv2;
        var shifted_data : mem_data_t;
        word_addr = addr[31:2];
        word_ofs = addr[1:0];
        // Shift word by appropriate offset
        // Assumes little endianness (LSB is at byte 0 of word, MSB at byte 3)
        shifted_data = bv_a_right_shift(bv_left_shift(3bv32, bv_zero_extend(30, word_ofs)), dmem[word_addr]);
        // TODO deal with alignment checks
        case
            (width == BYTE) : { new_rd_val = if (sext) then bv_sign_extend(24, shifted_data[7:0]) else bv_zero_extend(24, shifted_data[7:0]); }
            (width == HALF) : { new_rd_val = if (sext) then bv_sign_extend(16, shifted_data[15:0]) else bv_zero_extend(16, shifted_data[15:0]); }
            (width == WORD) : { new_rd_val = shifted_data; }
        esac
    }

    procedure do_mem_write(addr : reg_data_t, width : mem_data_width_t, value : reg_data_t)
        modifies dmem;
    {
        // TODO handle alignment
        var word_addr : mem_word_addr_t;
        var bit_ofs: bv32;
        var old_word : mem_data_t;
        var new_mem_data : mem_data_t;
        word_addr = addr[31:2];
        bit_ofs = bv_left_shift(3bv32, bv_zero_extend(30, addr[1:0]));
        old_word = dmem[word_addr];
        case
            (width == BYTE) : {
                old_word = old_word & (~bv_left_shift(bit_ofs, 0xFFbv32));
                new_mem_data = old_word | bv_left_shift(bit_ofs, value & 0xFFbv32);
            }
            (width == HALF) : {
                old_word = old_word & (~bv_left_shift(bit_ofs, 0xFFFFbv32));
                new_mem_data = old_word | bv_left_shift(bit_ofs, value & 0xFFFFbv32);
            }
            (width == WORD) : { new_mem_data = old_word | bv_left_shift(bit_ofs, value); }
        esac
        dmem[word_addr] = new_mem_data;
    }

    // ===== END STATE HELPER FUNCTIONS =====

    // ===== BEGIN INSTRUCTION EXECUTE FUNCTIONS =====
    procedure exec_i_arith(args : itype_arith_t)
        modifies regfile, pc;
    {
        var imm_ext : reg_data_t;
        var i : itype_arith_inst_t;
        var rs1_val : reg_data_t;
        var new_rd_val : reg_data_t;
        imm_ext = bv_sign_extend(20, args.imm);
        i = args.inst;
        rs1_val = regfile[args.rs1];
        case
            (i == ADDI) : { new_rd_val = rs1_val + imm_ext; }
            // FIX: bv_left_shift seems not to type check until it reaches the smt backend
            (i == SLTI) : { new_rd_val = if (imm_ext > rs1_val) then 1bv32 else 0bv32; }
            (i == SLTIU) : { new_rd_val = if (imm_ext >=_u rs1_val) then 1bv32 else 0bv32; }
            (i == XORI) : { new_rd_val = rs1_val ^ imm_ext; }
            (i == ORI) : { new_rd_val = rs1_val | imm_ext; }
            (i == ANDI) : { new_rd_val = rs1_val & imm_ext; }
            // TODO handle invalid instructions (restrict w/ assumption?)
        esac
        call do_reg_write(args.rd, new_rd_val);
        pc = pc + 4bv32;
    }

    procedure exec_i_shift(args : itype_shift_t)
        modifies regfile, pc;
    {
        var shamt_padded : reg_data_t;
        var inst : itype_shift_inst_t;
        var rs1_val : reg_data_t;
        var new_rd_val : reg_data_t;
        shamt_padded = bv_zero_extend(27, args.shamt);
        inst = args.inst;
        rs1_val = regfile[args.rs1];
        case
            (inst == SLLI) : { new_rd_val = bv_left_shift(shamt_padded, rs1_val); }
            (inst == SRAI) : { new_rd_val = bv_a_right_shift(shamt_padded, rs1_val); }
            (inst == SRLI) : { new_rd_val = bv_l_right_shift(shamt_padded, rs1_val); }
        esac
        call do_reg_write(args.rd, new_rd_val);
        pc = pc + 4bv32;
    }

    procedure exec_i_mem(args : itype_mem_t)
        modifies regfile, pc;
    {
        var addr : reg_data_t;
        var inst : itype_mem_inst_t;
        var new_rd_val : reg_data_t;
        addr = regfile[args.rs1] + bv_sign_extend(20, args.imm);
        inst = args.inst;
        case
            (inst == LB) : { call (new_rd_val) = do_mem_read(addr, BYTE, true); }
            (inst == LBU) : { call (new_rd_val) = do_mem_read(addr, BYTE, false); }
            (inst == LH) : { call (new_rd_val) = do_mem_read(addr, HALF, true); }
            (inst == LHU) : { call (new_rd_val) = do_mem_read(addr, HALF, false); }
            (inst == LW) : { call (new_rd_val) = do_mem_read(addr, WORD, true); }
        esac
        call do_reg_write(args.rd, new_rd_val);
        pc = pc + 4bv32;
    }

    procedure exec_s(args : stype_t)
        modifies dmem, pc;
    {
        // Returns memory value shifted/masked appropriately
        var addr : reg_data_t;
        var i : stype_inst_t;
        addr = regfile[args.rs1] + bv_sign_extend(20, args.imm);
        i = args.inst;
        case
            (i == SB) : { call do_mem_write(addr, BYTE, regfile[args.rs2]); }
            (i == SH) : { call do_mem_write(addr, HALF, regfile[args.rs2]); }
            (i == SW) : { call do_mem_write(addr, WORD, regfile[args.rs2]); }
        esac
        pc = pc + 4bv32;
    }
    // ===== END INSTRUCTION EXECUTE FUNCTIONS =====

    // Decodes and executes an instruction from IMEM
    procedure exec_next_inst()
        modifies pc, regfile, dmem;
    {
        var oc : bv7;
        var rs1 : bv5;
        var rs2 : bv5;
        var rd : bv5;
        var f3 : bv3;
        var f7 : bv7;
        var i_imm : bv12;
        var s_imm : bv12;
        var i_shift_inst : itype_shift_inst_t;
        var i_mem_inst : itype_mem_inst_t;
        var s_inst : stype_inst_t;
        oc = get_opcode(inst);
        rs1 = get_rs1(inst);
        rs2 = get_rs2(inst);
        rd = get_rd(inst);
        f3 = get_f3(inst);
        f7 = get_f7(inst);
        i_imm = get_i_imm(inst);
        s_imm = get_s_imm(inst);
        case
/*
            (oc == OPCODE_I_ARITH) : {
                if (f3 == F3_SLLI || f3 == F3_SRI) {
                    var args : itype_shift_t;
                    args.rs1 = rs1;
                    args.rd = rd;
                    args.shamt = i_imm[4:0];
                    case
                        (f3 == F3_SLLI) : { args.inst = slli; }
                        (f7[5:5] == 0bv1) : { args.inst = srli; }
                        (f7[5:5] == 1bv1) : { args.inst = srai; }
                    esac
                    call exec_i_shift(args);
                } else {
                    var args : itype_arith_t;
                    args.rs1 = rs1;
                    args.rd = rd;
                    args.imm = i_imm;
                    case
                        (f3 == F3_ADDI) : { args.inst = addi; }
                        (f3 == F3_SLTI) : { args.inst = slti; }
                        (f3 == F3_SLTIU) : { args.inst = sltiu; }
                        (f3 == F3_XORI) : { args.inst = xori; }
                        (f3 == F3_ORI) : { args.inst = ori; }
                        (f3 == F3_ANDI) : { args.inst = andi; }
                    esac
                    call exec_i_arith(args);
                }
            } 
            (oc == OPCODE_I_MEM) : {
                var args : itype_mem_t;
                args.rd = rd;
                args.rs1 = rs1;
                args.imm = i_imm;
                case
                    (f3 == F3_LB) : { args.inst = lb; }
                    (f3 == F3_LBU) : { args.inst = lbu; }
                    (f3 == F3_LH) : { args.inst = lh; }
                    (f3 == F3_LHU) : { args.inst = lhu; }
                    (f3 == F3_LW) : { args.inst = lw; }
                esac
                call exec_i_mem(args);
            }
            (oc == OPCODE_R) : {
                pc = pc + 4bv32;
            }
*/
            (oc == OPCODE_S) : {
                var args : stype_t;
                case
                    (f3 == F3_SB) : { s_inst = SB; }
                    (f3 == F3_SH) : { s_inst = SH; }
                    (f3 == F3_SW) : { s_inst = SW; }
                esac
                args = { s_inst, rs1, rs2, s_imm };
//                call exec_s(args);
            }
            (oc == OPCODE_B) : {
            }
            (oc == OPCODE_U) : {
                pc = pc + 4bv32;
            }
            (oc == OPCODE_J) : {
            }
        esac
    }

    init {
        assume (forall (r : reg_addr_t) :: regfile[r] == 0bv32);
        assume (forall (a : mem_word_addr_t) :: dmem[a] == 0bv32);
        inst = imem[0bv30];
        pc = 0bv32;
    }

    next {
        inst' = imem[pc_to_mem_addr(pc)];
        call exec_next_inst();
    }
}

module sanity {
    type * = common.*;

    var imem : mem_t;

    instance cpu_0 : cpu (imem : (imem));

    init {
        imem[0bv30] = 0x00000013bv32; // nop
        imem[1bv30] = 0x06400593bv32; // addi a1, x0, 100
        imem[2bv30] = 0x0C800613bv32; // addi a2, x0, 200
        imem[3bv30] = 0x06466593bv32; // ori  a1, a2, 100
    }

    next {
        next (cpu_0);
    }

    invariant s1 : (cpu_0.pc == 12bv32) ==> (cpu_0.regfile[11bv5] == 100bv32);
    invariant s2 : (cpu_0.pc == 16bv32) ==> (cpu_0.regfile[12bv5] == 200bv32);
    invariant s3 : (cpu_0.pc == 20bv32) ==> (cpu_0.regfile[11bv5] == 236bv32);

    control {
        vobj = bmc(5);
        check;
        print_results;
        vobj.print_cex(cpu_0.pc, cpu_0.inst, cpu_0.regfile);
    }
}

module main {
    type * = common.*;
    type * = instructions.*;
    define * = instructions.*;
    const * = instructions.*;
    const * = encdec.*;
    define * = encdec.*;

    var imem : mem_t;

    instance cpu_1 : cpu (imem : (imem));
    instance cpu_2 : cpu (imem : (imem));

    init {
        // Checks that only implemented instructions are generated
        assume (forall (a : mem_word_addr_t) :: get_opcode(imem[a]) == OPCODE_I_MEM || get_opcode(imem[a]) == OPCODE_I_ARITH || get_opcode(imem[a]) == OPCODE_S);
    }

    next {
        next (cpu_1);
        next (cpu_2);
    }

    invariant eq_regs : (forall (r : reg_addr_t) :: cpu_1.regfile[r] == cpu_2.regfile[r]);
    invariant eq_mem : (forall (a : mem_word_addr_t) :: cpu_1.dmem[a] == cpu_2.dmem[a]);
    invariant eq_pc : (cpu_1.pc == cpu_2.pc);
    invariant eq_inst : (cpu_1.inst == cpu_2.inst);

    control {
        vobj = bmc(3);
        check;
        print_results;
        vobj.print_cex(cpu_1.inst, cpu_2.inst, cpu_1.regfile, cpu_2.regfile);
    }
}

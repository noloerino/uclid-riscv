module common {
    type inst_t             = bv32;
    type pc_t               = bv32;
    type mem_word_addr_t    = bv30;
    type mem_data_t         = bv32; // for simplicity, memory is word-addressed
    type mem_t              = [mem_word_addr_t]mem_data_t;
    type reg_data_t         = bv32;
    type reg_addr_t         = bv5;
    type regfile_t          = [reg_addr_t]reg_data_t;
}

module instructions {
    type rtype_t = record { f7 : bv7, rs2: bv5, rs1 : bv5, f3: bv3, rd: bv5, opcode: bv7 };
    type itype_t = record { imm : bv12, rs1 : bv5, f3: bv3, rd: bv5, opcode: bv7 };
    type stype_t = record { imm_u : bv12, rs2 : bv5, f3: bv3, imm_l: bv5, opcode: bv7 };
    type btype_t = record { imm_u : bv12, rs2 : bv5, f3: bv3, imm_l: bv5, opcode: bv7 };
    type utype_t = record { imm : bv20, rd: bv5, opcode: bv7 };
    type jtype_t = record { imm : bv20, rd: bv5, opcode: bv7 };

    const OPCODE_I_MEM      : bv7 = 0b0000011bv7;
    const OPCODE_I_ARITH    : bv7 = 0b0010011bv7;
    const OPCODE_R          : bv7 = 0b0110011bv7;
    const OPCODE_S          : bv7 = 0b0100011bv7;
    const OPCODE_B          : bv7 = 0b1100011bv7;
    const OPCODE_U          : bv7 = 0b0010111bv7;
    const OPCODE_J          : bv7 = 0b1101111bv7;
}

module itype_arith {
    type * = common.*;
}

// Very similar to cpu model in example 3.2 of tutorial
// https://github.com/uclid-org/uclid/blob/master/tutorial/tutorial.pdf
module main {
    type * = common.*;
    const * = instructions.*;

    input imem  : mem_t;
    var dmem    : mem_t;
    var regfile : regfile_t;
    var pc      : pc_t;
    var inst    : inst_t;

    define pc_to_mem_addr(pc : pc_t) : mem_word_addr_t = pc[31:2];
    define i_imm(inst : inst_t) : bv12 = inst[11:0];
    define rs2(inst : inst_t) : reg_addr_t = inst[24:20];
    define rs1(inst : inst_t) : reg_addr_t = inst[19:15];
    define rd(inst : inst_t) : reg_addr_t = inst[11:7];

    const F3_ADDI   : bv3 = 0b000bv3;
    const F3_SLLI   : bv3 = 0b001bv3;
    const F3_SLTI   : bv3 = 0b010bv3;
    const F3_SLTIU  : bv3 = 0b011bv3;
    const F3_XORI   : bv3 = 0b100bv3;
    const F3_SRI    : bv3 = 0b101bv3;
    const F3_ORI    : bv3 = 0b110bv3;
    const F3_ANDI   : bv3 = 0b111bv3;

    synthesis function addi(rs1 : reg_addr_t, imm : bv12, regfile : regfile_t): reg_data_t;
    // invariant inv_addi_pc: addi(inst, state).pc == state.pc + 4bv32;
    invariant inv_addi_rd:
        addi(rs1(inst), i_imm(inst), regfile) == regfile[rs1(inst)] + bv_sign_extend(20, i_imm(inst));

    procedure compute_i_arith(inst : inst_t)
        returns (rd_val : reg_data_t)
    {
        var fields : instructions.itype_t;
        var imm_ext : reg_data_t;
        var shamt : bv5;
        var f3 : bv3;
        imm_ext  = bv_sign_extend(20, i_imm(inst));
        shamt = i_imm(inst)[4:0];
        case
            (f3 == F3_ADDI) : { rd_val = addi(rs1(inst), i_imm(inst), regfile); }
            // FIX: bv_left_shift seems not to type check until it reaches the smt backend
/*
            (f3 == F3_SLLI) : { rd_val = bv_left_shift(imm_ext, rs1_val); }
            (f3 == F3_SLTI) : { if (imm_ext > rs1_val) { rd_val = 1bv32; } else { rd_val = 0bv32; } }
            // TODO check how to do unsigned vs signed comparisons
            (f3 == F3_SLTIU) : { if (imm_ext > rs1_val) { rd_val = 1bv32; } else { rd_val = 0bv32; } }
            (f3 == F3_XORI) : { rd_val = rs1_val ^ imm_ext; }
            (f3 == F3_SRI) : {
                if (imm[10:10] == 0bv1) {
                    // TODO double check behavior for upper immediate bits
                    rd_val = bv_a_right_shift(bv_zero_extend(27, shamt), rs1_val);
                } else {
                    rd_val = bv_l_right_shift(bv_zero_extend(27, shamt), rs1_val);
                }
            }
            (f3 == F3_ORI) : { rd_val = rs1_val | imm_ext; }
            (f3 == F3_ANDI) : { rd_val = rs1_val & imm_ext; }
*/
            // TODO handle invalid instructions (restrict w/ assumption?)
            default : { rd_val = 0bv32; }
        esac
    }


    procedure exec_inst()
        modifies pc, regfile, dmem;
    {
        var opcode : bv7;
        var i_imm : bv12;
        var rs1 : bv5;
        var rd : bv5;
        var f3 : bv3;
        opcode = inst[6:0];
        case
            (opcode == OPCODE_I_ARITH) : {
                i_imm = inst[31:20];
                rs1 = inst[19:15];
                rd = inst[11:7];
                f3 = inst[14:12];
                call (regfile[rd]) = compute_i_arith(inst);
                pc = pc + 4bv32;
            } 
            (opcode == OPCODE_I_MEM) : {
                pc = pc + 4bv32;
            }
            (opcode == OPCODE_R) : {
                pc = pc + 4bv32;
            }
            (opcode == OPCODE_S) : {
                pc = pc + 4bv32;
            }
            (opcode == OPCODE_B) : {
            }
            (opcode == OPCODE_U) : {

                pc = pc + 4bv32;
            }
            (opcode == OPCODE_J) : {
            }
        esac
    }

    init {
        assume (forall (r : reg_addr_t) :: regfile[r] == 0bv32);
        assume (forall (a : mem_word_addr_t) :: dmem[a] == 0bv32);
        pc = 0bv32;
        inst = 0x13bv32; // nop
    }

    next {
        inst' = imem[pc_to_mem_addr(pc)];
        call exec_inst();
    }

    control {
        vobj = bmc(2);
        check;
        print_results;
        // vobj.print_cex(cpu_1.inst, cpu_2.inst, cpu_1.regfile, cpu_2.regfile);
    }
}


// Very similar to cpu model in example 3.2 of tutorial
// https://github.com/uclid-org/uclid/blob/master/tutorial/tutorial.pdf
module main {
    type * = common.*;
    const * = instructions.*;
    define * = instructions.*;

    input imem  : mem_t;
    var dmem    : mem_t;
    var regfile : regfile_t;
    var pc      : pc_t;
    var inst    : inst_t;

    synthesis function addi(rs1_val: reg_data_t, imm : bv12): reg_data_t;
    // invariant inv_addi_pc: addi(inst, state).pc == state.pc + 4bv32;
    invariant inv_addi_rd:
        addi(regfile[rs1(inst)], i_imm(inst)) == regfile[rs1(inst)] + bv_sign_extend(20, i_imm(inst));

    procedure compute_i_arith(inst : inst_t)
        returns (rd_val : reg_data_t)
    {
        var fields : instructions.itype_t;
        var imm_ext : reg_data_t;
        var shamt : bv5;
        var f3 : bv3;
        imm_ext  = bv_sign_extend(20, i_imm(inst));
        shamt = i_imm(inst)[4:0];
        case
            (f3 == F3_ADDI) : { rd_val = addi(regfile[rs1(inst)], i_imm(inst)); }
            // FIX: bv_left_shift seems not to type check until it reaches the smt backend
/*
            (f3 == F3_SLLI) : { rd_val = bv_left_shift(imm_ext, rs1_val); }
            (f3 == F3_SLTI) : { if (imm_ext > rs1_val) { rd_val = 1bv32; } else { rd_val = 0bv32; } }
            // TODO check how to do unsigned vs signed comparisons
            (f3 == F3_SLTIU) : { if (imm_ext > rs1_val) { rd_val = 1bv32; } else { rd_val = 0bv32; } }
            (f3 == F3_XORI) : { rd_val = rs1_val ^ imm_ext; }
            (f3 == F3_SRI) : {
                if (imm[10:10] == 0bv1) {
                    // TODO double check behavior for upper immediate bits
                    rd_val = bv_a_right_shift(bv_zero_extend(27, shamt), rs1_val);
                } else {
                    rd_val = bv_l_right_shift(bv_zero_extend(27, shamt), rs1_val);
                }
            }
            (f3 == F3_ORI) : { rd_val = rs1_val | imm_ext; }
            (f3 == F3_ANDI) : { rd_val = rs1_val & imm_ext; }
*/
            // TODO handle invalid instructions (restrict w/ assumption?)
            default : { rd_val = 0bv32; }
        esac
    }


    procedure exec_inst()
        modifies pc, regfile, dmem;
    {
        var opcode : bv7;
        var i_imm : bv12;
        var rs1 : bv5;
        var rd : bv5;
        var f3 : bv3;
        opcode = inst[6:0];
        case
            (opcode == OPCODE_I_ARITH) : {
                i_imm = inst[31:20];
                rs1 = inst[19:15];
                rd = inst[11:7];
                f3 = inst[14:12];
                call (regfile[rd]) = compute_i_arith(inst);
                pc = pc + 4bv32;
            } 
            (opcode == OPCODE_I_MEM) : {
                pc = pc + 4bv32;
            }
            (opcode == OPCODE_R) : {
                pc = pc + 4bv32;
            }
            (opcode == OPCODE_S) : {
                pc = pc + 4bv32;
            }
            (opcode == OPCODE_B) : {
            }
            (opcode == OPCODE_U) : {

                pc = pc + 4bv32;
            }
            (opcode == OPCODE_J) : {
            }
        esac
    }

    init {
        assume (forall (r : reg_addr_t) :: regfile[r] == 0bv32);
        assume (forall (a : mem_word_addr_t) :: dmem[a] == 0bv32);
        pc = 0bv32;
        inst = 0x13bv32; // nop
    }

    next {
        inst' = imem[pc_to_mem_addr(pc)];
        call exec_inst();
    }

    control {
        vobj = bmc(2);
        check;
        print_results;
        // vobj.print_cex(cpu_1.inst, cpu_2.inst, cpu_1.regfile, cpu_2.regfile);
    }
}
